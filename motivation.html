<!DOCTYPE html>
<html lang="en">
        <head>
        <meta charset="utf-8">
        <title>IndraDB / motivation</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link href="//fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="lib/skeleton-2.0.4/css/normalize.css">
        <link rel="stylesheet" href="lib/skeleton-2.0.4/css/skeleton.css">
        <link rel="stylesheet" href="css/site.css">
    </head>
    <body>
        <div class="container">
            <div class="row">
                <div class="column" style="margin-top: 50px">
                    <img src="logo-mini.png" alt="" width="50" height="50" style="float: left" />
                    <h1 style="position: relative; left: 10px; top: 5px;">
                        <a href="index.html">IndraDB</a> / motivation
                    </h1>

                    <p>
                        Companies like Amazon have a wealth of data for building personalization algorithms. They have used this to better their product. Smaller companies are massively disadvantaged, because they have less data to work with, and because they don't have an army of data scientists constantly experimenting with new algorithms.
                    </p>
                    <p>
                        IndraDB is designed to help level the playing the field. It is a graph database that can store massive amounts of data and facilitate the rapid development of algorithms that leverage that data.
                    </p>
                    <p>
                        Graphs provide a very natural way of modeling and exploring datasets. In an ecommerce setting, you would represent both users and items as vertices, and purchases as edges between vertices. You might also represent, for example, reviews of products as another type of edge. Graphs are flexible though in that they can accomodate all kinds of use cases - not just ecommerce.
                    </p>
                    <p>
                        Graphs also provide a very natural way of building advanced algorithms. Collaborative filtering and nearest neighbor-based recommendation algorithms can be built simply by walking the graph. And Google's great innovation in search was to rank results based off of centrality analysis of the graph of how websites link to each other.
                    </p>
                    <p>
                        Graph databases, are, of course, not a panacea. No type of database is. But graph databases do help tremendously in certain kinds of analytics-heavy use cases.
                    </p>
                    
                    <h2 id="why-haven-t-graph-databases-taken-off-">Why haven't graph databases taken off?</h2>
                    <p>
                        Despite these use cases, and despite the plethora of options, graph databases are rarely utilized outside of large companies. This is slowly changing, but the slow uptake has a few broad reasons:
                    </p>
                    <ul>
                        <li>
                            They're frequently employed for the wrong use cases, leading to disappointment. Given the current state of things, it rarely makes sense to use graph databases as a single source of truth; rather, they should be used as a way of remodeling data that's already stored in other databases. Graph databases also shouldn't be used, for example, for a CRUD-heavy application, where an RDBMS would do a better job.
                        </li>
                        <li>
                            Current solutions require a great deal of niche knowledge. This is most commonly reflected in their query languages, where the flexibility of graphs makes it tempting to make very complex query languages. But it also reflects in operational complexity, where it's sometimes overly-complicated to get started or maintain uptime. The latter risk factor is multiplied if the graph database is being used as a single source of truth, and its uptime is paramount.
                        </li>
                        <li>
                            Graph databases are usually designed to strictly model the relationships between things and not much else. Consequently, to use it in a practical setting, you generally need to stand up another type of database alongside for whatever doesn't fit. For example, very few graph databases have a notion of edge weights; if you want to represent something like user ratings, you need to store those ratings in an entirely different database.
                        </li>
                    </ul>

                    <h2 id="how-is-indradb-different-">How is IndraDB different?</h2>
                    <p>
                        Like many graph databases, IndraDB is built to store directed and typed graphs. Graphs are directed because an edge from vertex A to vertex B does not imply that there's an edge from vertex B to vertex A. Graphs are typed because each edge and node has a type (a short string) that identifies what &quot;class&quot; it's a part of. In an ecommerce setting, the vertex types might be &quot;user&quot; and &quot;product&quot;, and the edge types might be &quot;purchased&quot; and &quot;reviewed&quot;.
                    </p>
                    <p>
                        Also not uncommon among graph databases is IndraDB's support for pluggable datastores, which allow you to make different trade-offs in how the data is stored. If persistence doesn't matter, you can use the in-memory-only datastore. If you want to avoid as much network overhead as possible, you can use the RocksDB implementation. If you want to make it easy to poke around the data from different angles, or run multiple instances of IndraDB, you can use the postgres implementation.
                    </p>
                    <p>
                        Beyond that, though, there are a number of features IndraDB has that are uncommon among graph databases:
                    </p>
                    <ul>
                        <li>
                            A very simple query language and API, inspired by facebook's <a href="https://www.cs.cmu.edu/%7Epavlo/courses/fall2013/static/papers/11730-atc13-bronson.pdf">TAO</a>. While IndraDB supports more than TAO (e.g. multi-hop queries), it remains very simple relative to, e.g. <a href="https://github.com/cayleygraph/cayley/blob/master/docs/GizmoAPI.md">Ceyley's</a>. This substantially lowers the barrier to entry for end-users and for people writing clients and datastores in IndraDB, though it comes at the cost of making it more cumbersome to perform richer queries.
                        </li>
                        <li>
                            Support for graphs that are too large for complete processing. IndraDB queries are designed such that datastore implementations should be able to execute them in a reasonable amount of time, even if the graph is very large. For example, queries for edges yields paginated results, in case there's too many edges to pull at once.
                        </li>
                        <li>
                            Emphasis on minimizing operational headache. IndraDB is designed for you to be able to get it running quickly - whether on your laptop on your cloud server - with little to no tuning required.
                        </li>
                        <li>
                            Metadata, which allows you to tie key/value JSON to the graph data itself. Most graph databases only store how vertices are linked, and little to nothing else, where even rudimentary extensions like edge weight require you to lean on another database to be used in tandem. With IndraDB, you can use metadata to handle many of these use cases.
                        </li>
                        <li>
                            Flexibility of use. There are a variety of ways to plug into IndraDB such that you're not restricted to just using it as a library, or just using it through an HTTP API. These methods provide tradeoffs in ease of use versus performance. The simplest but least performant way to integrate with IndraDB is through its HTTP API. At a level below that, you can compose lua scripts that are callable from the HTTP API, but can combine many graph queries together while avoiding network overhead. At the lowest level, you can integrate directly with the IndraDB library. This provides maximal performance by avoiding all overhead at the cost of needing to write lower-level rust code. All methods of integration build off of the same API and query language, so the knowledge you build integrating in one way is portable to the other ways.
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </body>
</html>
